import { Budget, Category, Expense } from "../models/index.js";
import { Op, fn, col, literal } from "sequelize";
import { getMlSignals } from "./mlClient.service.js";
import { generateBudgetExplanationsBatch } from "./budgetExplanation.service.js";

// Configuration constants
const MIN_BUDGET_AMOUNT = 100; // Minimum budget threshold in INR
const MAX_BUDGET_INCREASE = 1.25; // Max 25% increase from current
const MAX_BUDGET_DECREASE = 0.85; // Max 15% decrease from current

export const getBudgetsWithUsage = async (userId, month) => {
  const start = month
    ? new Date(`${month}-01`)
    : new Date(new Date().getFullYear(), new Date().getMonth(), 1);

  const end = new Date(start);
  end.setMonth(start.getMonth() + 1);

  console.log("[GET_BUDGETS] Range:", start, "→", end);

  const budgets = await Budget.findAll({
    where: {
      userId,
      period: "monthly",
    },
    include: [
      {
        model: Category,
        attributes: ["id", "name"],
      },
    ],
  });

  console.log("[GET_BUDGETS] Budgets fetched:", budgets.length);

  const spentRows = await Expense.findAll({
    where: {
      userId,
      type: "debit",
      createdAt: {
        [Op.gte]: start,
        [Op.lt]: end,
      },
    },
    attributes: [
      [col("Expense.category_id"), "categoryId"],
      [fn("SUM", col("Expense.amount")), "spent"],
    ],
    group: [col("Expense.category_id")],
  });

  console.log("[GET_BUDGETS] Spent rows:", spentRows.length);

  const spentMap = {};
  spentRows.forEach((row) => {
    const key = row.get("categoryId") || "uncategorized";
    spentMap[key] = Number(row.get("spent"));
  });

  return budgets.map((budget) => {
    const categoryId = budget.categoryId || "uncategorized";
    const spent = spentMap[categoryId] || 0;
    const limit = Number(budget.monthlyLimit);

    const remaining = Math.max(limit - spent, 0);
    const usagePercent = limit > 0 ? (spent / limit) * 100 : 0;

    return {
      budgetId: budget.id,
      category: budget.Category?.name || "Uncategorized",
      monthlyLimit: limit,
      spent,
      remaining,
      usagePercent: Number(usagePercent.toFixed(2)),
      isAutoGenerated: budget.isAutoGenerated,
      explanation: budget.explanation,
    };
  });
};

/**
 * Calculate weighted average with more weight on recent months
 * @param {Array} history - Array of {month, amount} sorted from oldest to newest
 * @returns {number} Weighted average
 */
const calculateWeightedAverage = (history) => {
  if (!history.length) return 0;

  // Sort by month descending (most recent first)
  const sorted = [...history].sort((a, b) => b.month.localeCompare(a.month));

  // Dynamic weights based on history length
  // Most recent month gets highest weight, decreasing for older months
  let totalWeight = 0;
  let weightedSum = 0;

  sorted.forEach((item, index) => {
    // Weight decreases exponentially: 1, 0.7, 0.5, 0.35, 0.25...
    const weight = Math.pow(0.7, index);
    weightedSum += item.amount * weight;
    totalWeight += weight;
  });

  return totalWeight > 0 ? weightedSum / totalWeight : 0;
};

/**
 * Get monthly spending history for all categories in a single query (N+1 optimization)
 */
const getAllCategoryMonthlyHistory = async (userId, startDate, endDate) => {
  const historyRows = await Expense.findAll({
    where: {
      userId,
      type: "debit",
      createdAt: {
        [Op.gte]: startDate,
        [Op.lt]: endDate,
      },
    },
    attributes: [
      [col("Expense.category_id"), "categoryId"],
      [fn("DATE_TRUNC", "month", col("createdAt")), "month"],
      [fn("SUM", col("amount")), "amount"],
    ],
    group: [col("Expense.category_id"), "month"],
    order: [[literal("month"), "ASC"]],
  });

  // Group by category
  const historyMap = {};
  historyRows.forEach((row) => {
    const categoryId = row.get("categoryId") || "uncategorized";
    if (!historyMap[categoryId]) {
      historyMap[categoryId] = [];
    }
    historyMap[categoryId].push({
      month: row.get("month").toISOString().slice(0, 7),
      amount: Number(row.get("amount")),
    });
  });

  return historyMap;
};

/**
 * Build a lookup map from categoryId to category name
 */
const getCategoryNameMap = async () => {
  const categories = await Category.findAll({
    attributes: ["id", "name"],
  });

  const nameMap = {};
  categories.forEach((cat) => {
    nameMap[cat.id] = cat.name;
  });

  return nameMap;
};

export const generateBudgetsForUser = async ({
  userId,
  months = 3,
  bufferPercent = 10,
}) => {
  const endDate = new Date();
  const startDate = new Date();
  startDate.setMonth(endDate.getMonth() - months);

  console.log("[BUDGET_GEN] User:", userId);
  console.log("[BUDGET_GEN] Range:", startDate, "→", endDate);

  // Fetch category names for human-readable explanations
  const categoryNameMap = await getCategoryNameMap();
  console.log("[BUDGET_GEN] Category names loaded:", Object.keys(categoryNameMap).length);

  // Get total spending per category
  const spendRows = await Expense.findAll({
    where: {
      userId,
      type: "debit",
      createdAt: {
        [Op.gte]: startDate,
        [Op.lt]: endDate,
      },
    },
    attributes: [
      [col("Expense.category_id"), "categoryId"],
      [fn("SUM", col("Expense.amount")), "totalSpent"],
    ],
    group: [col("Expense.category_id")],
  });

  console.log("[BUDGET_GEN] Spend rows:", spendRows.length);

  if (!spendRows.length) {
    console.log("[BUDGET_GEN] No spend rows found, exiting");
    return [];
  }

  // OPTIMIZATION: Fetch all monthly history in one query instead of N queries
  const allCategoryHistory = await getAllCategoryMonthlyHistory(userId, startDate, endDate);
  console.log("[BUDGET_GEN] Fetched history for categories:", Object.keys(allCategoryHistory).length);

  const existingBudgets = await Budget.findAll({
    where: {
      userId,
      period: "monthly",
    },
  });

  console.log("[BUDGET_GEN] Existing budgets:", existingBudgets.length);

  const budgetMap = {};
  existingBudgets.forEach((b) => {
    const key = b.categoryId || "uncategorized";
    budgetMap[key] = b;
  });

  const results = [];
  const explanationInputs = [];
  // Map to link category name back to categoryId for storing explanation
  const categoryNameToIdMap = {};

  for (const row of spendRows) {
    const categoryId = row.get("categoryId");
    const key = categoryId || "uncategorized";
    const totalSpent = Number(row.get("totalSpent"));

    // Get human-readable category name
    const categoryName = categoryId ? (categoryNameMap[categoryId] || "Unknown") : "Uncategorized";
    categoryNameToIdMap[categoryName] = categoryId;

    console.log("[BUDGET_GEN] Category:", categoryName, "(", categoryId, ") Total:", totalSpent);

    // Get history from pre-fetched data (N+1 optimization)
    const history = allCategoryHistory[key] || [];

    // Use weighted average (more weight on recent months)
    const avgMonthly = history.length > 0
      ? calculateWeightedAverage(history)
      : totalSpent / months;

    // Base budget with buffer
    let suggested = avgMonthly * (1 + bufferPercent / 100);

    // Get ML signals for enhanced predictions
    const mlSignals = await getMlSignals({
      userId,
      category: categoryName, // Use name instead of ID for ML
      history,
    });

    if (mlSignals) {
      const { predicted_spend, volatility_score, trend } = mlSignals;

      // Enhanced volatility adjustment - higher volatility = more buffer
      const volatilityMultiplier = volatility_score > 0.5 ? 0.2 : 0.1;
      suggested += avgMonthly * volatility_score * volatilityMultiplier;

      // Trend adjustments - more aggressive for uptrends
      if (trend === "up") suggested *= 1.08;      // 8% increase for uptrend
      if (trend === "down") suggested *= 0.95;    // 5% decrease for downtrend

      // ML prediction anchor - trust ML if it suggests higher
      suggested = Math.max(suggested, predicted_spend);
    }

    // Apply minimum budget threshold
    suggested = Math.max(suggested, MIN_BUDGET_AMOUNT);

    // Use category NAME (not ID) for explanation inputs
    explanationInputs.push({
      category: categoryName,  // Human-readable name
      categoryId: categoryId,  // Keep ID for mapping back
      avgMonthlySpend: avgMonthly,
      suggestedBudget: suggested,
      mlUsed: Boolean(mlSignals),
      trend: mlSignals?.trend,
      volatility: mlSignals?.volatility_score,
      bufferPercent,
      monthsAnalyzed: history.length,
    });

    const existing = budgetMap[key];

    // Skip if user has manually set this budget
    if (existing && !existing.isAutoGenerated) continue;

    if (existing) {
      const current = Number(existing.monthlyLimit);
      // Apply rate limiting to prevent wild swings
      suggested = Math.min(suggested, current * MAX_BUDGET_INCREASE);  // Max +25%
      suggested = Math.max(suggested, current * MAX_BUDGET_DECREASE);  // Max -15%

      // Ensure minimum is still respected after rate limiting
      suggested = Math.max(suggested, MIN_BUDGET_AMOUNT);

      existing.monthlyLimit = suggested.toFixed(2);
      existing.isAutoGenerated = true;
      results.push(existing);
    } else {
      const budget = await Budget.create({
        userId,
        categoryId,
        monthlyLimit: suggested.toFixed(2),
        period: "monthly",
        isAutoGenerated: true,
      });

      results.push(budget);
    }
  }

  // Generate explanations using category NAMES
  const explanations =
    explanationInputs.length > 0
      ? await generateBudgetExplanationsBatch(explanationInputs)
      : {};

  console.log("[BUDGET_GEN] Explanations generated for:", Object.keys(explanations));

  // Map explanations back to budgets using category name
  for (const budget of results) {
    // Find the category name for this budget
    const categoryName = categoryNameMap[budget.categoryId] || "Uncategorized";
    budget.explanation = explanations[categoryName] ?? null;
    await budget.save();
  }

  console.log("[BUDGET_GEN] Final budgets count:", results.length);
  return results;
};
