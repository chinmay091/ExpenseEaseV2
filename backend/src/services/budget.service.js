import { Budget, Category, Expense } from "../models/index.js";
import { Op, fn, col } from "sequelize";
import { getMlSignals } from "./mlClient.service.js";
import { generateBudgetExplanationsBatch } from "./budgetExplanation.service.js";

export const getBudgetsWithUsage = async (userId, month) => {
  const start = month
    ? new Date(`${month}-01`)
    : new Date(new Date().getFullYear(), new Date().getMonth(), 1);

  const end = new Date(start);
  end.setMonth(start.getMonth() + 1);

  console.log("[GET_BUDGETS] Range:", start, "→", end);

  const budgets = await Budget.findAll({
    where: {
      userId,
      period: "monthly",
    },
    include: [
      {
        model: Category,
        attributes: ["id", "name"],
      },
    ],
  });

  console.log("[GET_BUDGETS] Budgets fetched:", budgets.length);

  const spentRows = await Expense.findAll({
    where: {
      userId,
      type: "debit",
      createdAt: {
        [Op.gte]: start,
        [Op.lt]: end,
      },
    },
    attributes: [
      [col("Expense.category_id"), "categoryId"],
      [fn("SUM", col("Expense.amount")), "spent"],
    ],
    group: [col("Expense.category_id")],
  });

  console.log("[GET_BUDGETS] Spent rows:", spentRows.length);

  const spentMap = {};
  spentRows.forEach((row) => {
    const key = row.get("categoryId") || "uncategorized";
    spentMap[key] = Number(row.get("spent"));
  });

  return budgets.map((budget) => {
    const categoryId = budget.categoryId || "uncategorized";
    const spent = spentMap[categoryId] || 0;
    const limit = Number(budget.monthlyLimit);

    const remaining = Math.max(limit - spent, 0);
    const usagePercent = limit > 0 ? (spent / limit) * 100 : 0;

    return {
      budgetId: budget.id,
      category: budget.Category?.name || "Uncategorized",
      monthlyLimit: limit,
      spent,
      remaining,
      usagePercent: Number(usagePercent.toFixed(2)),
      isAutoGenerated: budget.isAutoGenerated,
      explanation: budget.explanation,
    };
  });
};

export const generateBudgetsForUser = async ({
  userId,
  months = 3,
  bufferPercent = 10,
}) => {
  const endDate = new Date();
  const startDate = new Date();
  startDate.setMonth(endDate.getMonth() - months);

  console.log("[BUDGET_GEN] User:", userId);
  console.log("[BUDGET_GEN] Range:", startDate, "→", endDate);

  const spendRows = await Expense.findAll({
    where: {
      userId,
      type: "debit",
      createdAt: {
        [Op.gte]: startDate,
        [Op.lt]: endDate,
      },
    },
    attributes: [
      [col("Expense.category_id"), "categoryId"],
      [fn("SUM", col("Expense.amount")), "totalSpent"],
    ],
    group: [col("Expense.category_id")],
  });

  console.log("[BUDGET_GEN] Spend rows:", spendRows.length);

  if (!spendRows.length) {
    console.log("[BUDGET_GEN] No spend rows found, exiting");
    return [];
  }

  const existingBudgets = await Budget.findAll({
    where: {
      userId,
      period: "monthly",
    },
  });

  console.log("[BUDGET_GEN] Existing budgets:", existingBudgets.length);

  const budgetMap = {};
  existingBudgets.forEach((b) => {
    const key = b.categoryId || "uncategorized";
    budgetMap[key] = b;
  });

  const results = [];
  const explanationInputs = [];

  for (const row of spendRows) {
    const categoryId = row.get("categoryId");
    const key = categoryId || "uncategorized";
    const totalSpent = Number(row.get("totalSpent"));

    console.log("[BUDGET_GEN] Category:", categoryId, "Total:", totalSpent);

    const avgMonthly = totalSpent / months;
    let suggested = avgMonthly * (1 + bufferPercent / 100);

    const historyRows = await Expense.findAll({
      where: {
        userId,
        type: "debit",
        categoryId,
        createdAt: {
          [Op.gte]: startDate,
          [Op.lt]: endDate,
        },
      },
      attributes: [
        [fn("DATE_TRUNC", "month", col("createdAt")), "month"],
        [fn("SUM", col("amount")), "amount"],
      ],
      group: ["month"],
      order: [[fn("DATE_TRUNC", "month", col("createdAt")), "ASC"]],
    });

    const history = historyRows.map((r) => ({
      month: r.get("month").toISOString().slice(0, 7),
      amount: Number(r.get("amount")),
    }));

    const mlSignals = await getMlSignals({
      userId,
      category: categoryId || "Uncategorized",
      history,
    });

    if (mlSignals) {
      const { predicted_spend, volatility_score, trend } = mlSignals;

      suggested += avgMonthly * volatility_score * 0.1;
      if (trend === "up") suggested += avgMonthly * 0.05;
      if (trend === "down") suggested -= avgMonthly * 0.05;

      suggested = Math.max(suggested, predicted_spend * 0.9);
    }

    explanationInputs.push({
      category: categoryId || "Uncategorized",
      avgMonthlySpend: avgMonthly,
      suggestedBudget: suggested,
      mlUsed: Boolean(mlSignals),
      trend: mlSignals?.trend,
      volatility: mlSignals?.volatility_score,
      bufferPercent,
      monthsAnalyzed: history.length,
    });

    const existing = budgetMap[key];

    if (existing && !existing.isAutoGenerated) continue;

    if (existing) {
      const current = Number(existing.monthlyLimit);
      suggested = Math.min(suggested, current * 1.25);
      suggested = Math.max(suggested, current * 0.9);

      existing.monthlyLimit = suggested.toFixed(2);
      existing.isAutoGenerated = true;
      results.push(existing);
    } else {
      const budget = await Budget.create({
        userId,
        categoryId,
        monthlyLimit: suggested.toFixed(2),
        period: "monthly",
        isAutoGenerated: true,
      });

      results.push(budget);
    }
  }

  const explanations =
    explanationInputs.length > 0
      ? await generateBudgetExplanationsBatch(explanationInputs)
      : {};

  for (const budget of results) {
    const key = budget.categoryId || "Uncategorized";
    budget.explanation = explanations[key] ?? null;
    await budget.save();
  }

  console.log("[BUDGET_GEN] Final budgets count:", results.length);
  return results;
};
