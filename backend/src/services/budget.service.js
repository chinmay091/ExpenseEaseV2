import { Budget, Category, Expense } from "../models/index.js";
import { Op, fn, col, literal } from "sequelize";
import { getMlSignals } from "./mlClient.service.js";
import { generateBudgetExplanationsBatch } from "./budgetExplanation.service.js";

const MIN_BUDGET_AMOUNT = 100;
const MAX_BUDGET_INCREASE = 1.25;
const MAX_BUDGET_DECREASE = 0.85;

export const getBudgetsWithUsage = async (userId, month) => {
  const start = month
    ? new Date(`${month}-01`)
    : new Date(new Date().getFullYear(), new Date().getMonth(), 1);

  const end = new Date(start);
  end.setMonth(start.getMonth() + 1);

  console.log("[GET_BUDGETS] Range:", start, "→", end);

  const budgets = await Budget.findAll({
    where: {
      userId,
      period: "monthly",
    },
    include: [
      {
        model: Category,
        attributes: ["id", "name"],
      },
    ],
  });

  console.log("[GET_BUDGETS] Budgets fetched:", budgets.length);

  const spentRows = await Expense.findAll({
    where: {
      userId,
      type: "debit",
      createdAt: {
        [Op.gte]: start,
        [Op.lt]: end,
      },
    },
    attributes: [
      [col("Expense.category_id"), "categoryId"],
      [fn("SUM", col("Expense.amount")), "spent"],
    ],
    group: [col("Expense.category_id")],
  });

  console.log("[GET_BUDGETS] Spent rows:", spentRows.length);

  const spentMap = {};
  spentRows.forEach((row) => {
    const key = row.get("categoryId") || "uncategorized";
    spentMap[key] = Number(row.get("spent"));
  });

  return budgets.map((budget) => {
    const categoryId = budget.categoryId || "uncategorized";
    const spent = spentMap[categoryId] || 0;
    const limit = Number(budget.monthlyLimit);

    const remaining = Math.max(limit - spent, 0);
    const usagePercent = limit > 0 ? (spent / limit) * 100 : 0;

    return {
      budgetId: budget.id,
      category: budget.Category?.name || "Uncategorized",
      monthlyLimit: limit,
      spent,
      remaining,
      usagePercent: Number(usagePercent.toFixed(2)),
      isAutoGenerated: budget.isAutoGenerated,
      explanation: budget.explanation,
    };
  });
};

const calculateWeightedAverage = (history) => {
  if (!history.length) return 0;

  const sorted = [...history].sort((a, b) => b.month.localeCompare(a.month));

  let totalWeight = 0;
  let weightedSum = 0;

  sorted.forEach((item, index) => {
    const weight = Math.pow(0.7, index);
    weightedSum += item.amount * weight;
    totalWeight += weight;
  });

  return totalWeight > 0 ? weightedSum / totalWeight : 0;
};

const getAllCategoryMonthlyHistory = async (userId, startDate, endDate) => {
  const historyRows = await Expense.findAll({
    where: {
      userId,
      type: "debit",
      createdAt: {
        [Op.gte]: startDate,
        [Op.lt]: endDate,
      },
    },
    attributes: [
      [col("Expense.category_id"), "categoryId"],
      [fn("DATE_TRUNC", "month", col("createdAt")), "month"],
      [fn("SUM", col("amount")), "amount"],
    ],
    group: [col("Expense.category_id"), "month"],
    order: [[literal("month"), "ASC"]],
  });

  const historyMap = {};
  historyRows.forEach((row) => {
    const categoryId = row.get("categoryId") || "uncategorized";
    if (!historyMap[categoryId]) {
      historyMap[categoryId] = [];
    }
    historyMap[categoryId].push({
      month: row.get("month").toISOString().slice(0, 7),
      amount: Number(row.get("amount")),
    });
  });

  return historyMap;
};

const getCategoryNameMap = async () => {
  const categories = await Category.findAll({
    attributes: ["id", "name"],
  });

  const nameMap = {};
  categories.forEach((cat) => {
    nameMap[cat.id] = cat.name;
  });

  return nameMap;
};

export const generateBudgetsForUser = async ({
  userId,
  months = 3,
  bufferPercent = 10,
}) => {
  const endDate = new Date();
  const startDate = new Date();
  startDate.setMonth(endDate.getMonth() - months);

  console.log("[BUDGET_GEN] User:", userId);
  console.log("[BUDGET_GEN] Range:", startDate, "→", endDate);

  const categoryNameMap = await getCategoryNameMap();
  console.log("[BUDGET_GEN] Category names loaded:", Object.keys(categoryNameMap).length);

  const spendRows = await Expense.findAll({
    where: {
      userId,
      type: "debit",
      createdAt: {
        [Op.gte]: startDate,
        [Op.lt]: endDate,
      },
    },
    attributes: [
      [col("Expense.category_id"), "categoryId"],
      [fn("SUM", col("Expense.amount")), "totalSpent"],
    ],
    group: [col("Expense.category_id")],
  });

  console.log("[BUDGET_GEN] Spend rows:", spendRows.length);

  if (!spendRows.length) {
    console.log("[BUDGET_GEN] No spend rows found, exiting");
    return [];
  }

  const allCategoryHistory = await getAllCategoryMonthlyHistory(userId, startDate, endDate);
  console.log("[BUDGET_GEN] Fetched history for categories:", Object.keys(allCategoryHistory).length);

  const existingBudgets = await Budget.findAll({
    where: {
      userId,
      period: "monthly",
    },
  });

  console.log("[BUDGET_GEN] Existing budgets:", existingBudgets.length);

  const budgetMap = {};
  existingBudgets.forEach((b) => {
    const key = b.categoryId || "uncategorized";
    budgetMap[key] = b;
  });

  const results = [];
  const explanationInputs = [];
  const categoryNameToIdMap = {};

  for (const row of spendRows) {
    const categoryId = row.get("categoryId");
    const key = categoryId || "uncategorized";
    const totalSpent = Number(row.get("totalSpent"));

    const categoryName = categoryId ? (categoryNameMap[categoryId] || "Unknown") : "Uncategorized";
    categoryNameToIdMap[categoryName] = categoryId;

    console.log("[BUDGET_GEN] Category:", categoryName, "(", categoryId, ") Total:", totalSpent);

    const history = allCategoryHistory[key] || [];

    const avgMonthly = history.length > 0
      ? calculateWeightedAverage(history)
      : totalSpent / months;

    let suggested = avgMonthly * (1 + bufferPercent / 100);

    const mlSignals = await getMlSignals({
      userId,
      category: categoryName,
      history,
    });

    if (mlSignals) {
      const { predicted_spend, volatility_score, trend } = mlSignals;

      const volatilityMultiplier = volatility_score > 0.5 ? 0.2 : 0.1;
      suggested += avgMonthly * volatility_score * volatilityMultiplier;

      if (trend === "up") suggested *= 1.08;
      if (trend === "down") suggested *= 0.95;

      suggested = Math.max(suggested, predicted_spend);
    }

    suggested = Math.max(suggested, MIN_BUDGET_AMOUNT);

    explanationInputs.push({
      category: categoryName,
      categoryId: categoryId,
      avgMonthlySpend: avgMonthly,
      suggestedBudget: suggested,
      mlUsed: Boolean(mlSignals),
      trend: mlSignals?.trend,
      volatility: mlSignals?.volatility_score,
      bufferPercent,
      monthsAnalyzed: history.length,
    });

    const existing = budgetMap[key];

    if (existing && !existing.isAutoGenerated) continue;

    if (existing) {
      const current = Number(existing.monthlyLimit);
      suggested = Math.min(suggested, current * MAX_BUDGET_INCREASE);
      suggested = Math.max(suggested, current * MAX_BUDGET_DECREASE);
      suggested = Math.max(suggested, MIN_BUDGET_AMOUNT);

      existing.monthlyLimit = suggested.toFixed(2);
      existing.isAutoGenerated = true;
      results.push(existing);
    } else {
      const budget = await Budget.create({
        userId,
        categoryId,
        monthlyLimit: suggested.toFixed(2),
        period: "monthly",
        isAutoGenerated: true,
      });

      results.push(budget);
    }
  }

  const explanations =
    explanationInputs.length > 0
      ? await generateBudgetExplanationsBatch(explanationInputs)
      : {};

  console.log("[BUDGET_GEN] Explanations generated for:", Object.keys(explanations));

  for (const budget of results) {
    const categoryName = categoryNameMap[budget.categoryId] || "Uncategorized";
    budget.explanation = explanations[categoryName] ?? null;
    await budget.save();
  }

  console.log("[BUDGET_GEN] Final budgets count:", results.length);
  return results;
};
