import { Budget, Category, Expense } from "../models/index.js";
import { Op, fn, col } from "sequelize";

export const getBudgetsWithUsage = async (userId, month) => {
  const start = month
    ? new Date(`${month}-01`)
    : new Date(new Date().getFullYear(), new Date().getMonth(), 1);

  const end = month
    ? new Date(new Date(start).setMonth(start.getMonth() + 1))
    : new Date(new Date(start).setMonth(start.getMonth() + 1));

  // 1) Fetch budgets
  const budgets = await Budget.findAll({
    where: {
      userId,
      period: "monthly",
    },
    include: [
      {
        model: Category,
        attributes: ["id", "name"],
      },
    ],
  });

  // 2) Compute spent per category for the month (debits only)
  const spentRows = await Expense.findAll({
    where: {
      userId,
      type: "debit",
      createdAt: {
        [Op.gte]: start,
        [Op.lt]: end,
      },
    },
    attributes: [
      [col("Expense.category_id"), "categoryId"],
      [fn("SUM", col("amount")), "spent"],
    ],
    group: [col("Expense.category_id")],
  });

  // Map categoryId -> spent
  const spentMap = {};
  spentRows.forEach((row) => {
    const key = row.categoryId || "uncategorized";
    spentMap[key] = Number(row.get("spent"));
  });

  // 3) Build response
  return budgets.map((budget) => {
    const categoryId = budget.categoryId || "uncategorized";
    const spent = spentMap[categoryId] || 0;
    const limit = Number(budget.monthlyLimit);
    const remaining = Math.max(limit - spent, 0);
    const usagePercent = limit > 0 ? (spent / limit) * 100 : 0;

    return {
      budgetId: budget.id,
      category: budget.Category?.name || "Uncategorized",
      monthlyLimit: limit,
      spent,
      remaining,
      usagePercent: Number(usagePercent.toFixed(2)),
      isAutoGenerated: budget.isAutoGenerated,
    };
  });
};

export const generateBudgetsForUser = async ({
  userId,
  months = 3,
  bufferPercent = 10,
}) => {
  const endDate = new Date();
  const startDate = new Date();
  startDate.setMonth(endDate.getMonth() - months);

  // 1️⃣ Aggregate spending per category
  const spendRows = await Expense.findAll({
    where: {
      userId,
      type: "debit",
      createdAt: {
        [Op.gte]: startDate,
        [Op.lt]: endDate,
      },
    },
    attributes: [
      [col("Expense.category_id"), "categoryId"],
      [fn("SUM", col("Expense.amount")), "totalSpent"],
    ],
    group: [col("Expense.category_id")],
  });

  if (!spendRows.length) return [];

  // 2️⃣ Fetch existing budgets
  const existingBudgets = await Budget.findAll({
    where: {
      userId,
      period: "monthly",
    },
  });

  const budgetMap = {};
  existingBudgets.forEach((b) => {
    const key = b.categoryId || "uncategorized";
    budgetMap[key] = b;
  });

  const results = [];

  // 3️⃣ Generate or update budgets
  for (const row of spendRows) {
    const categoryId = row.get("categoryId");
    const key = categoryId || "uncategorized";
    const totalSpent = Number(row.get("totalSpent"));

    const avgMonthly = totalSpent / months;
    const rawSuggested = avgMonthly * (1 + bufferPercent / 100);
    
    console.log("ML signals for", categoryId, mlSignals);

    const existing = budgetMap[key];

    if (existing && !existing.isAutoGenerated) {
      console.log("Skipping manual budget for", categoryId);
      continue;
    }
    
    let finalBudget = rawSuggested;

    // 4️⃣ Apply safety caps if updating
    if (existing) {
      const current = Number(existing.monthlyLimit);
      const maxIncrease = current * 1.25;
      const maxDecrease = current * 0.9;

      finalBudget = Math.min(finalBudget, maxIncrease);
      finalBudget = Math.max(finalBudget, maxDecrease);

      existing.monthlyLimit = finalBudget.toFixed(2);
      existing.isAutoGenerated = true;
      await existing.save();

      results.push(existing);
    } else {
      const budget = await Budget.create({
        userId,
        categoryId,
        monthlyLimit: finalBudget.toFixed(2),
        period: "monthly",
        isAutoGenerated: true,
      });

      results.push(budget);
    }
  }

  return results;
};
